# -*- coding: utf-8 -*-
"""Scotland Yard Game - Master

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1i7e7Lf9a2t5dU-4sL7uO4t3FsNbmKbgr
"""

raw_data = '''
1:8,1-9,1-46,3-58,2-46,2
2:20,1-10,1
3:11,1-4,1-12,1-22,2-23,2
4:3,1-13,1
5:15,1-16,1
6:7,1-29,1
7:6,1-17,1-42,2
8:1,1-19,1-18,1
9:19,1-1,1-20,1
10:2,1-11,1-34,1-21,1
11:3,1-10,1-22,1
12:3,1-23,1
13:4,1-14,1-24,1-23,1-14,2-52,2-23,2-89,3-46,3-67,3
14:13,1-15,1-25,1-13,2-15,2
15:5,1-16,1-28,1-26,1-14,1-29,2-41,2-14,2
16:5,1-15,1-29,1-28,1
17:7,1-30,1-42,1-29,1
18:8,1-31,1-43,1
19:8,1-9,1-32,1
20:2,1-33,1-9,1
21:33,1-10,1
22:11,1-23,1-35,1-34,1-3,2-23,2-65,2-34,2
23:22,1-12,1-13,1-37,1-22,2-3,2-13,2-67,2
24:13,1-37,1-38,1
25:14,1-39,1-38,1
26:15,1-39,1-27,1
27:26,1-28,1-40,1
28:27,1-15,1-16,1-41,1
29:6,1-17,1-42,1-41,1-16,1-42,2-55,2-41,2-15,2
30:17,1-42,1
31:18,1-43,1-44,1
32:19,1-33,1-44,1-45,1
33:21,1-46,1-32,1-20,1
34:10,1-22,1-48,1-47,1-22,2-63,2-46,2
35:22,1-48,1-36,1-65,1
36:35,1-37,1-49,1
37:23,1-24,1-50,1-36,1
38:24,1-25,1-51,1-50,1
39:25,1-26,1-52,1-51,1
40:27,1-41,1-52,1-53,1
41:28,1-29,1-40,1-54,1-15,2-29,2-52,2-87,2
42:17,1-30,1-56,1-72,1-29,1-7,2-29,2-72,2
43:18,1-31,1-57,1
44:31,1-32,1-58,1
45:32,1-58,1-59,1-60,1-46,1
46:45,1-33,1-47,1-61,1-58,2-1,2-34,2-78,2-1,3-74,3-79,3-13,3
47:46,1-62,1-34,1
48:62,1-34,1-35,1-63,1
49:36,1-50,1-66,1
50:49,1-37,1-38,1
51:38,1-39,1-52,1-67,1-68,1
52:40,1-69,1-51,1-39,1-41,2-86,2-67,2-13,2
53:69,1-40,1-54,1
54:53,1-41,1-55,1-70,1
55:54,1-71,1-29,2-89,2
56:42,1-91,1
57:43,1-58,1-73,1
58:57,1-44,1-45,1-59,1-74,1-1,2-74,2-46,2-77,2-75,1
59:58,1-45,1-76,1-75,1
60:45,1-61,1-76,1
61:76,1-46,1-62,1-78,1-60,1
62:61,1-47,1-48,1-79,1
63:79,1-48,1-64,1-80,1-79,2-34,2-65,2-100,2
64:63,1-81,1-65,1
65:64,1-35,1-66,1-82,1-63,2-22,2-67,2-82,2
66:65,1-49,1-67,1-82,1
67:66,1-51,1-68,1-84,1-52,2-65,2-82,2-102,2-23,2-79,3-111,3-13,3-89,3
68:67,1-51,1-69,1-85,1
69:68,1-52,1-53,1-86,1
70:54,1-71,1-87,1
71:70,1-55,1-72,1-89,1
72:71,1-42,1-90,1-91,1-42,2-105,2-107,2
73:57,1-74,1-92,1
74:73,1-92,1-58,1-75,1-58,2-94,2-46,3
75:74,1-58,1-94,1-59,1
76:59,1-60,1-61,1-77,1
77:76,1-78,1-96,1-95,1-58,2-78,2-124,2-94,2
78:77,1-61,1-79,1-97,1-77,2-46,2-79,2
79:78,1-62,1-63,1-98,1-78,2-63,2-46,3-93,3-111,3-67,3
80:63,1-99,1-100,1
81:100,1-64,1-82,1
82:81,1-65,1-66,1-101,1-100,2-65,2-67,2-140,2
83:101,1-102,1
84:67,1-85,1
85:68,1-103,1-84,1
86:69,1-104,1-103,1-52,2-87,2-116,2-102,2
87:70,1-88,1-41,2-86,2-105,2
88:89,1-117,1-87,1
89:71,1-105,1-88,1-55,2-105,2-67,3-159,3-13,3-140,3
90:72,1-91,1-105,1
91:56,1-107,1-105,1-90,1-72,1
92:73,1-74,1-93,1
93:92,1-94,1-94,2-79,3
94:75,1-95,1-93,1-74,2-93,2-77,2
95:94,1-77,1-122,1
96:77,1-97,1-109,1
97:78,1-98,1-109,1-96,1
98:79,1-99,1-110,1-97,1
99:80,1-112,1-110,1-98,1
100:112,1-111,2-63,2-80,1-81,1-82,2-101,1-113,1
101:82,1-100,1-83,1-114,1
102:115,1-127,2-83,1-67,2-103,1-86,2
103:102,1-85,1-86,1
104:86,1-116,1
105:118,1-118,2-87,2-89,2-89,1-90,1-72,2-106,1-107,2-91,1
106:105,1-107,1
107:119,1-161,2-105,2-106,1-72,2-91,1
108:
109:96,1-97,1-110,1-124,1
110:98,1-99,1-111,1-109,1
111:153,3-163,3-124,1-124,2-79,3-110,1-100,2-67,3-112,1
112:99,1-100,1-125,1-111,1
113:125,1-100,1-114,1
114:113,1-101,1-115,1-126,1-132,1-131,1
115:126,1-114,1-102,1-127,1-118,4-157,4
116:142,2-128,1-127,1-127,2-104,1-86,2-117,1-118,2
117:116,1-88,1-118,1-129,1
118:117,1-116,2-135,2-105,2-105,1-119,1-115,4
119:118,1-107,1-136,1
120:121,1-144,1
121:120,1-122,1-145,1
122:95,1-121,1-123,1-146,1-144,2-123,2
123:122,1-122,2-144,2-137,1-148,1-149,1-165,2-124,2-124,1
124:109,1-111,1-130,1-138,1-123,1-77,2-111,2-153,2-123,2
125:112,1-113,1-131,1
126:114,1-115,1-127,1-140,1
127:133,1-133,2-126,1-115,1-102,2-116,1-116,2-134,1
128:134,1-116,1-129,1-142,1
129:117,1-128,1-142,1-143,1-135,1
130:124,1-131,1-139,1
131:114,1-125,1-130,1
132:114,1-140,1
133:127,1-141,1-140,1-140,2-127,2-157,2
134:127,1-128,1-142,1-141,1
135:129,1-118,2-136,1-161,2-161,1-159,2-143,1
136:135,1-119,1-162,1
137:123,1-147,1
138:124,1-152,1-150,1
139:130,1-140,1-154,1-153,1
140:132,1-126,1-133,1-156,1-154,1-139,1-82,2-133,2-156,2-154,2-153,3-159,3-89,3
141:134,1-142,1-158,1-133,1
142:128,1-129,1-143,1-159,1-158,1-141,1-134,1-116,2-159,2-157,2
143:129,1-135,1-160,1-159,1-142,1
144:120,1-145,1-177,1-122,2-123,2-163,2
145:121,1-146,1-144,1
146:147,1-163,1-145,1-122,1
147:137,1-164,1-146,1
148:123,1-149,1-164,1
149:123,1-150,1-165,1-148,1
150:138,1-151,1-149,1
151:150,1-152,1-166,1-165,1
152:138,1-153,1-151,1
153:139,1-154,1-167,1-166,1-152,1-154,2-184,2-180,2-124,2-111,3-140,3-185,3-163,3
154:140,1-155,1-153,1-139,1-140,2-156,2-153,2
155:154,1-156,1-168,1-167,1
156:140,1-157,1-169,1-155,1-140,2-157,2-184,2-154,2
157:158,1-170,1-156,1-133,2-142,2-185,2-156,2-194,4-115,4
158:141,1-142,1-171,1-157,1
159:142,1-143,1-160,1-188,1-172,1-142,2-135,2-161,2-199,2-187,2-140,3-185,3-89,3
160:143,1-161,1-159,1-173,1
161:174,1-160,1-135,1-107,2-199,2-159,2-135,2
162:136,1-175,1
163:146,1-177,1-191,2-144,2-176,2-111,3-153,3
164:147,1-148,1-179,1-178,1
165:149,1-151,1-180,1-179,1-123,2-180,2-191,2
166:153,1-183,1-181,1-151,1
167:155,1-168,1-183,1-153,1
168:155,1-184,1-167,1
169:156,1-184,1
170:157,1-171,1-185,1
171:158,1-172,1-198,1-186,1-170,1
172:171,1-187,1-159,1
173:160,1-188,1-174,1-200,1
174:161,1-173,1-175,1
175:174,1-162,1-200,1
176:177,1-189,1-163,2-190,2
177:176,1-144,1-163,1
178:164,1-191,1-189,1
179:164,1-165,1-191,1
180:165,1-181,1-193,1-165,2-190,2-153,2-184,2
181:180,1-166,1-182,1-193,1
182:181,1-183,1-195,1
183:166,1-182,1-167,1-196,1
184:168,1-196,1-197,1-169,1-185,1-153,2-180,2-156,2-185,2
185:184,1-170,1-186,1-184,2-157,2-199,2-187,2-153,3-159,3
186:185,1-171,1-198,1
187:198,1-172,1-188,1-199,2-159,2-185,2
188:187,1-159,1-173,1-199,1
189:176,1-178,1-190,1
190:189,1-191,1-192,1-176,2-191,2-180,2
191:190,1-178,1-179,1-192,1-163,2-190,2-165,2
192:190,1-191,1-194,1
193:180,1-181,1-194,1
194:192,1-193,1-195,1-157,4
195:194,1-182,1-197,1
196:183,1-197,1-184,1
197:195,1-196,1-184,1
198:186,1-171,1-187,1
199:188,1-200,1-185,2-161,2-159,2-187,2-185
200:199,1-173,1-175,1
'''

def create_array(data):
    # Splitting the data into individual lines
    lines = data.strip().split('\n')

    # Initializing the result array with an empty array at index 0
    result = [[]]

    # Iterating through each line and extracting the tuples
    for line in lines:
        parts = line.split(':')
        if len(parts) == 2:
            tuples = parts[1].split('-')
            tuple_list = []
            for t in tuples:
                nums = t.split(',')
                if len(nums) == 2:
                    tuple_list.append((int(nums[0]), int(nums[1])))
            result.append(tuple_list)
    # print(result)
    return(result)

import pdb

from ast import Break
import heapq
import math
from collections import deque, defaultdict

"""
When initializing pawn, the entry for history should be it's starting location with 0 is cost.
to create mr.x: mr_x = Pawn("Black", (get_start_location(starting_nodes), 0), True, [0,0,0,5,2])
to create detective: d1 = Pawn("Blue", (get_start_location(starting_nodes, 0), False, [10,8,4,0,0])

color = pawn color. Mr.X should be black.
history = location history in tuples (node #, ticket # used to get there) starting node ticket # is 0.
location = returns current location.
is_MrX = true/false.
tickets = array of available tickets. [taxi, bus, underground, black, double_move], Detective starting tickets is [10,8,4,0,0].
          We will likely only track/limit black and double tickets, if anything at all.
"""
class Pawn:
    def __init__(self, color, history, is_MrX, tickets):
        self.color = color  # Mr. X should be black.
        self.history = history
        self.location = history[-1][0]
        self.is_MrX = is_MrX
        self.tickets = tickets
        self.intended_path = []

    def update_location(self):
        self.location = self.history[-1][0]

    def move(self, new_location):
        self.history.append(new_location)
        self.update_location()

    def update_intended_path(self, new_path):
        self.intended_path = new_path



class ScotlandYardGame:
    import random


    def __init__(self, adjacency_list, starting_nodes):
        self.adjacency_list = adjacency_list
        self.possible_x_locations = set(starting_nodes)
        self.detectives_locations = []
        self.pawns = []
        self.current_round = 1

    def get_detective_locations(self):
        detective_locations = []
        for pawn in self.pawns[1:]:
            detective_locations.append(pawn.location)
        return detective_locations

    def set_possible_x_locations(self, x_nodes):
        self.possible_x_locations = {x_nodes}

    def update_possible_x_locations(self):
        new_possible_locations = self.possible_x_locations
        d_locations = self.get_detective_locations()
        for d in d_locations:
            new_possible_locations.discard(d)
        self.possible_x_locations = new_possible_locations

    def update_possible_x_locations_from_ticket(self, edge_cost):
        new_possible_locations = set()
        if edge_cost == 4:
            for current_location in self.possible_x_locations:
                for connection in self.adjacency_list[current_location]:
                    node, cost = connection
                    new_possible_locations.add(node)
        else:
            for current_location in self.possible_x_locations:
                for connection in self.adjacency_list[current_location]:
                    node, cost = connection
                    if cost == edge_cost:
                        new_possible_locations.add(node)
        d_locations = self.get_detective_locations()
        for d in d_locations:
            new_possible_locations.discard(d)
        self.possible_x_locations = new_possible_locations

    def reveal_x_location(self, location):
        self.possible_x_locations = {location}

    def set_num_detectives(self):
        while True:
            try:
                user_input = int(input("Please enter the number of detectives from 1 to 5: "))
                if 1 <= user_input <= 5:
                    return user_input
                else:
                    print("Input must be between 1 and 5.")
            except ValueError:
                print("Invalid input. Please enter an integer.")

    def get_start_node(self, available_start_nodes):
        starting_location = self.random.choice(list(available_start_nodes))
        available_start_nodes.remove(starting_location)

        return starting_location, available_start_nodes

    def generate_pawns(self, num_detectives, starting_nodes):
        available_nodes = starting_nodes
        pawns = []
        mr_x_start_tickets = [20,20,20,5,2]
        detective_start_tickets = [10,8,4,0,0]
        pawn_colors = ("Black", "Blue", "Purple", "Red", "Green", "Yellow", "White")

        for i in range(num_detectives + 1):
            start_node, available_nodes = self.get_start_node(available_nodes)
            if (i > 0):
                pawn = Pawn(pawn_colors[i], [(start_node, 0)], False, detective_start_tickets)
                pawns.append(pawn)
            else:
                pawn = Pawn(pawn_colors[i], [(start_node, 0)], True, mr_x_start_tickets)
                pawns.append(pawn)
        return pawns

    def start_game(self):
        num_of_detectives = self.set_num_detectives()
        self.pawns = self.generate_pawns(num_of_detectives, starting_nodes)

    def get_possible_x_locations(self):
        return self.possible_x_locations

    def get_adjacent_node_count(self, nodes, positions):
        max_count = 0;
        best_nodes = set()
        if isinstance(nodes, int):
            nodes = {nodes}
        for node in nodes:
            count = len(self.get_adjacent_nodes(node, positions))
            if count > max_count:
                best_nodes = {node}
            elif count == max_count:
                best_nodes.add(node)
        for position in positions:
            best_nodes.discard(position)
        return best_nodes


    def get_adjacent_nodes(self, nodes, positions):
        if isinstance(nodes, int):
            nodes = {nodes}
        adjacent_nodes = set()
        for node in nodes:
            for edge in self.adjacency_list[node]:
                adjacent_nodes.add((edge[0]))
        for position in positions:
            adjacent_nodes.discard(position)
        return adjacent_nodes

    def get_detective_adjacent_nodes(self, nodes, positions):
        if isinstance(nodes, int):
            nodes = {nodes}
        adjacent_nodes = set()
        for node in nodes:
            for edge in adjacency_list[node]:
                adjacent_node, edge_cost = edge
                if edge_cost != 4:
                    adjacent_nodes.add((adjacent_node))
        for position in positions:
            adjacent_nodes.discard(position)
        return adjacent_nodes

    def get_adjacent_nodes_with_cost(self, current_node, positions):
        adjacent_nodes = set()
        for edge in adjacency_list[current_node]:
            adjacent_node, edge_cost = edge
            adjacent_nodes.add((adjacent_node, edge_cost))
        filtered_set = {t for t in adjacent_nodes if t[0] not in positions}
        return filtered_set

    def get_adjacent_nodes_from_cost(self, current_node, target_cost, positions):
        adjacent_nodes_with_cost = set()
        if target_cost == 4:
            for edge in adjacency_list[current_node]:
                adjacent_node, edge_cost = edge
                adjacent_nodes_with_cost.add((adjacent_node))
        else:
            for edge in adjacency_list[current_node]:
                adjacent_node, edge_cost = edge
                if edge_cost == target_cost:
                    adjacent_nodes_with_cost.add(adjacent_node)
        for position in positions:
            adjacent_nodes_with_cost.discard(position)
        return adjacent_nodes_with_cost

    def get_common_nodes(self, d_nodes, x_nodes):
        if isinstance(x_nodes, int):
            x_nodes = {x_nodes}
        if isinstance(d_nodes, int):
            d_nodes = {d_nodes}
        common_nodes = x_nodes & d_nodes
        if common_nodes:
            return common_nodes
        else:
            return None

    def remove_detectives_based_on_intent(self, nodes, intents, positions, i):
      for node in nodes.copy():
          for intent in intents:
              if i >= len(intent):
                  continue
              if intent == []:
                  continue
              if (i == 1):
                  for position in positions:
                      nodes.discard(position)
              if node == intent[i][0]:
                  nodes.discard(node)
              if i+1 < len(intent):
                  if node == intent[i+1][0]:
                      nodes.discard(node)

    def get_expanding_common_nodes(self, d_nodes, x_nodes, intents, positions):
        counter = 0

        while counter < 30:
            common_nodes = self.get_common_nodes(d_nodes, x_nodes)
            if common_nodes:
                return common_nodes, counter
            elif counter % 2 == 0:
                counter += 1
                d_nodes = self.get_detective_adjacent_nodes(d_nodes, positions)
                i = math.ceil(counter / 2)
                # Remove detectives based on their intents
                self.remove_detectives_based_on_intent(d_nodes, intents, positions, i)
            else:
                counter += 1
                x_nodes = self.get_adjacent_nodes(x_nodes, positions)
                i = math.floor(counter / 2)
                # Remove Mr. X based on his intents
                self.remove_detectives_based_on_intent(x_nodes, intents, positions, i)
        return None

    def bfs_shortest_path(self, start_node, end_node, n_steps):
        # Queue for BFS that stores (current_node, path, step_count)
        queue = deque([(start_node, [(start_node, 0)], 0)])  # Initialize with the start node and zero steps taken
        # List to store paths that exactly match n_steps
        valid_paths = []

        while queue:
            current_node, path, step_count = queue.popleft()

            # Continue to explore if within the step limit
            if step_count < n_steps:
                for neighbor, weight in self.adjacency_list[current_node]:
                    if weight == 4:
                        continue  # Skip edges with weight 4
                    new_path = list(path)  # Make a copy of the current path
                    new_path.append((neighbor, weight))
                    queue.append((neighbor, new_path, step_count + 1))
            elif step_count == n_steps and current_node == end_node:
                # Add path if it ends at the end_node and matches the step count exactly
                valid_paths.append(path)

        return valid_paths


    def get_best_path(self, d_node, x_nodes, intents, positions):
        positions = self.get_detective_locations()

        result = self.get_expanding_common_nodes(d_node, x_nodes, intents, positions)
        if result is not None:
            common_nodes, counter = result
        else:
            # common_nodes = set(self.pawns[0].location)
            # counter = 0
            return None
        paths = []

        steps_detective = math.ceil(counter / 2)
        steps_x = math.floor(counter / 2)

        self.update_possible_x_locations()
        positions = self.get_detective_locations()
        # print("common nodes:", common_nodes, "positions:", positions)
        best_nodes = self.get_adjacent_node_count(common_nodes, positions)

        for node in best_nodes:
            path = self.bfs_shortest_path(d_node, node, steps_detective)
            if not paths:  # If all_paths is empty, initialize it with the first path
                paths = path
            else:  # If all_paths already has elements, extend the existing path with the new one
                paths += path  # This appends the elements of path to the end of all_paths

        for path in paths:
            for position in positions:
                if position == path[1][0]:
                    index_to_remove = paths.index(path)
                    paths.pop(index_to_remove)


        max_neighbors = -1
        best_path = None
        for path in paths:
            path_neighbor_count = 0
            unique_nodes = set(node for node, _ in path)
            for node in unique_nodes:
                neighbors = self.get_adjacent_nodes(node, positions)
                path_neighbor_count += len(neighbors)
            if path_neighbor_count > max_neighbors:
                max_neighbors = path_neighbor_count
                best_path = path
        return best_path

    def ai_move(self, pawn, x_nodes, intents):
        positions = self.get_detective_locations()
        path = self.get_best_path(pawn.location, x_nodes, intents, positions)
        if path is None:
            return None;
        pawn.update_intended_path(path)
        # print("pawn", pawn.color, "intent:", path)
        pawn.move(path[1])
        intents.append(pawn.intended_path)
        self.update_possible_x_locations()
        return intents

    def all_ai_move(self, x_nodes):
        intents = []
        for pawn in self.pawns[1:]:
            self.update_possible_x_locations()
            x_nodes = self.get_possible_x_locations()
            intents = self.ai_move(pawn, x_nodes, intents)

def run_scotland_yard_game(adjacency_list, starting_nodes):
    import sys
    game = ScotlandYardGame(adjacency_list, starting_nodes)
    game.start_game()
    reveal_rounds = [3, 8, 13, 18]
    intents = []
    we_gamin = True

    ## TESTING ###
    # for i, pawn in enumerate(game.pawns):
    #     print(f"Pawn {i}:")
    #     print("Color:", pawn.color)
    #     print("Is Mr. X:", pawn.is_MrX)
    #     print("Tickets:", pawn.tickets)
    #     print("Current Node:", pawn.location)
    #     print("History:", pawn.history)
    #     print()
    ## TESTING ###

    print()
    print("Updated possible locations for Mr. X:", sorted(game.get_possible_x_locations()))
    while we_gamin:
        rounds_until_next_reveal = 0
        rounds_until_next_reveal = min([round_num for round_num in reveal_rounds if round_num >= game.current_round], default=None)

        print(f"Round {game.current_round}:")
        round_completed = True  # Assume the round will complete unless a reveal is unsuccessful
        intents = []


        try:
            if rounds_until_next_reveal is not None:
                print("Detective locations:", game.get_detective_locations())
                print("Your current location:", game.pawns[0].location, "(moves until reveal:", rounds_until_next_reveal+1 - game.current_round, ')')
            possible_moves = sorted(game.get_adjacent_nodes_with_cost(game.pawns[0].location, game.get_detective_locations()))
            if(possible_moves):
                print("Your possible moves:", sorted(game.get_adjacent_nodes_with_cost(game.pawns[0].location, game.get_detective_locations()), key=lambda x: (x[1], x[0])))
            else:
                print("You are trapped")
                break


            edge_cost = int(input("Enter the edge cost used by Mr. X (or enter -1 to quit): "))
            if edge_cost == -1:

                break
            if edge_cost == 0:
                edge_cost = int(input("Who's history (0-5)?"))
                if edge_cost < len(game.pawns):
                  print("Movement history:", game.pawns[edge_cost].history)
                continue
            elif 1 <= edge_cost <= 4:
                possible_nodes = sorted(game.get_adjacent_nodes_from_cost(game.pawns[0].location, edge_cost, game.get_detective_locations()))
                print("Your possible destinations:", possible_nodes)
                target_node = int(input("Enter your destination number, or -1 to go back: "))
                if target_node == -1:
                    continue
                if target_node in possible_nodes:
                    game.pawns[0].move((target_node, edge_cost))
                    game.update_possible_x_locations_from_ticket(edge_cost)
                    print()
                    print()
                    print("Updated possible locations for Mr. X:", sorted(game.get_possible_x_locations()))
                else:
                  print("Invalid destination.")
                  continue
            else:
              raise ValueError
        except ValueError:
            print("Please enter a numeric edge cost from 1 to 4.")
            round_completed = False

        if game.current_round in reveal_rounds:
            game.set_possible_x_locations(game.pawns[0].location)
            print("Mr. X's location revealed!:", game.get_possible_x_locations())


        if round_completed:
            # all AI detectives move
            intents = []
            for pawn in game.pawns[1:]:
                game.update_possible_x_locations()
                x_nodes = game.get_possible_x_locations()
                intents = game.ai_move(pawn, x_nodes, intents)
                if intents is None:
                    print("Mr.X has been caught or trapped. Wouldn't you rather play Global Thermonuclear War?")
                    we_gamin = False
                    break
                d_positions = game.get_detective_locations()
                for i in d_positions:
                    if (game.pawns[0].location == i):
                        print("Mr.X has been caught or trapped. Wouldn't you rather play Global Thermonuclear War?")
                        we_gamin = False
                        break
            game.current_round += 1  # Only increment the round if it was completed successfully

    print("Game ended.")

# Sample adjacency list (simplified version, please replace with the actual game data)
# The adjacency list here needs to be replaced with the actual Scotland Yard board game graph data.
adjacency_list = create_array(raw_data)

# Starting nodes for Mr. X and detectives, as per game rules
starting_nodes = {13, 26, 29, 34, 50, 53, 91, 94, 103, 112, 117, 132, 138, 141, 155, 174, 197, 198}


# Start the game
run_scotland_yard_game(adjacency_list, starting_nodes)